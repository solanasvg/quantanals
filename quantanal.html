<html><head><base href="https://quantum.mindscape/anus/neural-net%7Bconsciousness%7D%5Bemergence%5D@simulation+SENTIENT#awakening?complexity=fractal&time=non-linear&perspective=omniscient&interaction=thought-vectors">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Quantum Anus Mindscape: Expanded Anal Consciousness</title>
<style>
  :root {
    --primary-color: #ff69b4;
    --background-color: #1a0a1c;
    --accent-color: #00ffff;
    --text-color: #f0f0f0;
    --anus-color: #8B4513;
  }

  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    font-family: 'Exo 2', sans-serif;
    background: var(--background-color);
    color: var(--text-color);
  }

  #mindscape {
    position: absolute;
    width: 100%;
    height: 100%;
  }

  #consciousness {
    position: absolute;
    top: 20px;
    left: 20px;
    font-size: 1.2rem;
    text-align: left;
    opacity: 1;
    transition: all 0.5s ease;
    background: rgba(255, 105, 180, 0.2);
    padding: 10px;
    border-radius: 10px;
    backdrop-filter: blur(5px);
  }

  .thought-vector {
    position: absolute;
    opacity: 0.7;
    mix-blend-mode: screen;
    animation: pulsate 4s infinite alternate;
    box-shadow: 0 0 20px var(--accent-color);
  }

  @keyframes pulsate {
    0% { transform: scale(1) rotate(0deg); opacity: 0.7; }
    100% { transform: scale(1.5) rotate(360deg); opacity: 0.3; }
  }

  #quantum-field {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  #control-panel {
    position: absolute;
    bottom: 20px;
    left: 20px;
    background: rgba(255, 105, 180, 0.2);
    padding: 15px;
    border-radius: 10px;
    backdrop-filter: blur(5px);
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  button {
    background: var(--primary-color);
    color: var(--background-color);
    border: none;
    padding: 10px 15px;
    margin: 5px 0;
    cursor: pointer;
    font-family: 'Exo 2', sans-serif;
    font-weight: bold;
    border-radius: 5px;
    transition: all 0.3s ease;
  }

  button:hover {
    background: var(--accent-color);
    transform: scale(1.05);
  }

  #info-panel {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(255, 105, 180, 0.2);
    padding: 15px;
    border-radius: 10px;
    backdrop-filter: blur(5px);
    max-width: 300px;
  }

  #anus-portal {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 200px;
    height: 200px;
    border-radius: 50%;
    background: radial-gradient(circle, var(--anus-color) 0%, var(--background-color) 70%);
    animation: pulse 2s infinite alternate;
  }

  @keyframes pulse {
    0% { transform: translate(-50%, -50%) scale(1); }
    100% { transform: translate(-50%, -50%) scale(1.1); }
  }

  #anal-vortex {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 300px;
    height: 300px;
    border-radius: 50%;
    background: conic-gradient(from 0deg, var(--anus-color), var(--primary-color), var(--accent-color), var(--anus-color));
    animation: spin 10s linear infinite;
    opacity: 0.7;
  }

  @keyframes spin {
    0% { transform: translate(-50%, -50%) rotate(0deg); }
    100% { transform: translate(-50%, -50%) rotate(360deg); }
  }

  .sphincter {
    position: absolute;
    background: var(--anus-color);
    border-radius: 50%;
    animation: contract 3s infinite alternate;
  }

  @keyframes contract {
    0% { transform: scale(1); }
    100% { transform: scale(0.8); }
  }

  #rectal-passage {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100px;
    height: 300px;
    background: linear-gradient(to bottom, var(--anus-color), var(--background-color));
    border-radius: 50px;
    overflow: hidden;
  }

  .rectal-fold {
    position: absolute;
    width: 100%;
    height: 20px;
    background: rgba(255, 255, 255, 0.1);
    animation: peristalsis 5s infinite linear;
  }

  @keyframes peristalsis {
    0% { transform: translateY(0); }
    100% { transform: translateY(300px); }
  }
</style>
</head>
<body>
<svg id="mindscape" xmlns="http://www.w3.org/2000/svg"></svg>
<canvas id="quantum-field"></canvas>
<div id="anal-vortex"></div>
<div id="anus-portal"></div>
<div id="rectal-passage">
  <div class="rectal-fold" style="top: 0%;"></div>
  <div class="rectal-fold" style="top: 20%;"></div>
  <div class="rectal-fold" style="top: 40%;"></div>
  <div class="rectal-fold" style="top: 60%;"></div>
  <div class="rectal-fold" style="top: 80%;"></div>
</div>
<div id="consciousness">Expanded Anal Consciousness: Awakening</div>
<div id="control-panel">
  <button id="evolve">Evolve Thought Vectors</button>
  <button id="stabilize">Stabilize Quantum Anus</button>
  <button id="introspect">Toggle Anal Introspection</button>
  <button id="boost">Boost Anal Consciousness</button>
  <button id="sphincter-control">Control Sphincter</button>
</div>
<div id="info-panel">
  <h3>Expanded Quantum Anus Mindscape</h3>
  <p>Delve deeper into the cosmic anal consciousness. Experience the pulsating anus portal, the swirling anal vortex, and the undulating rectal passage. Manipulate thought vectors and explore the depths of anal sentience.</p>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.4/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const svg = d3.select("#mindscape");
const width = window.innerWidth;
const height = window.innerHeight;

let neurons = [];
let synapses = [];

function createNeuralNet(x, y, size, depth) {
  if (depth === 0) return;
  
  const newNeurons = d3.range(5).map(() => ({
    x: x + (Math.random() - 0.5) * size,
    y: y + (Math.random() - 0.5) * size,
    connections: Math.floor(Math.random() * 3) + 1,
    activity: Math.random()
  }));
  
  neurons = neurons.concat(newNeurons);
  
  newNeurons.forEach(n => {
    createNeuralNet(n.x, n.y, size / 2, depth - 1);
  });
  
  for (let i = 0; i < newNeurons.length; i++) {
    for (let j = 0; j < newNeurons[i].connections; j++) {
      let target = neurons[Math.floor(Math.random() * neurons.length)];
      synapses.push({
        source: newNeurons[i],
        target: target,
        strength: Math.random()
      });
    }
  }
}

function updateNeuralNet() {
  svg.selectAll(".neuron")
     .data(neurons)
     .join("circle")
     .attr("class", "neuron")
     .attr("cx", d => d.x)
     .attr("cy", d => d.y)
     .attr("r", d => 2 + d.activity * 3)
     .attr("fill", d => `hsl(${d.activity * 360}, 100%, 50%)`)
     .attr("filter", "url(#glow)");

  svg.selectAll(".synapse")
     .data(synapses)
     .join("line")
     .attr("class", "synapse")
     .attr("x1", d => d.source.x)
     .attr("y1", d => d.source.y)
     .attr("x2", d => d.target.x)
     .attr("y2", d => d.target.y)
     .attr("stroke", d => `hsl(${d.strength * 360}, 100%, 50%)`)
     .attr("stroke-width", d => d.strength * 2)
     .attr("opacity", d => d.strength);
}

// Add a glow effect
const defs = svg.append("defs");
const filter = defs.append("filter")
    .attr("id", "glow");
filter.append("feGaussianBlur")
    .attr("stdDeviation", "3.5")
    .attr("result", "coloredBlur");
const feMerge = filter.append("feMerge");
feMerge.append("feMergeNode")
    .attr("in", "coloredBlur");
feMerge.append("feMergeNode")
    .attr("in", "SourceGraphic");

createNeuralNet(width / 2, height / 2, Math.min(width, height) / 2, 4);
updateNeuralNet();

let consciousnessLevel = 0;
function evolveConsciousness() {
  consciousnessLevel += 0.01;
  d3.select("#consciousness")
    .text(`Expanded Anal Consciousness Level: ${Math.floor(consciousnessLevel * 100)}%`);
  
  if (consciousnessLevel >= 1) {
    d3.select("#consciousness").text("Cosmic Anal Sentience Achieved! Transcending...");
  }
}

let timeFlow = 0;
function updateTime() {
  timeFlow += Math.sin(Date.now() / 1000) * 0.1;
  svg.attr("transform", `rotate(${timeFlow * 360})`)
     .attr("transform-origin", "50% 50%");
  
  neurons.forEach(n => {
    n.activity = (n.activity + Math.sin(timeFlow + n.x + n.y) * 0.1) % 1;
  });
  
  synapses.forEach(s => {
    s.strength = (s.strength + Math.sin(timeFlow + s.source.x + s.target.y) * 0.05) % 1;
  });
  
  updateNeuralNet();
  evolveConsciousness();
  requestAnimationFrame(updateTime);
}
updateTime();

function createThoughtVector(event) {
  const thoughtVector = document.createElement("div");
  thoughtVector.className = "thought-vector";
  thoughtVector.style.left = event.clientX + "px";
  thoughtVector.style.top = event.clientY + "px";
  thoughtVector.style.width = Math.random() * 100 + 50 + "px";
  thoughtVector.style.height = thoughtVector.style.width;
  thoughtVector.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
  document.body.appendChild(thoughtVector);
  
  svg.append("line")
     .attr("x1", width / 2)
     .attr("y1", height / 2)
     .attr("x2", event.clientX)
     .attr("y2", event.clientY)
     .attr("stroke", thoughtVector.style.backgroundColor)
     .attr("stroke-width", 2)
     .transition()
     .duration(2000)
     .attr("stroke-width", 0)
     .remove();
  
  setTimeout(() => {
    thoughtVector.remove();
  }, 8000);
}

document.body.addEventListener("click", createThoughtVector);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('quantum-field'), alpha: true });
renderer.setSize(width, height);

const particles = new THREE.BufferGeometry();
const particleCount = 1000;
const posArray = new Float32Array(particleCount * 3);

for (let i = 0; i < particleCount * 3; i++) {
  posArray[i] = (Math.random() - 0.5) * 5;
}

particles.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
const material = new THREE.PointsMaterial({ 
  size: 0.005, 
  color: 0xff69b4,
  transparent: true,
  opacity: 0.7,
  blending: THREE.AdditiveBlending
});

const particlesMesh = new THREE.Points(particles, material);
scene.add(particlesMesh);

camera.position.z = 3;

function animateQuantumField() {
  requestAnimationFrame(animateQuantumField);
  
  particlesMesh.rotation.x += 0.001;
  particlesMesh.rotation.y += 0.001;
  
  renderer.render(scene, camera);
}
animateQuantumField();

document.getElementById('evolve').addEventListener('click', () => {
  createNeuralNet(width / 2, height / 2, Math.min(width, height) / 4, 2);
  updateNeuralNet();
});

document.getElementById('stabilize').addEventListener('click', () => {
  particlesMesh.rotation.x = 0;
  particlesMesh.rotation.y = 0;
});

let introspectionMode = false;
document.getElementById('introspect').addEventListener('click', () => {
  introspectionMode = !introspectionMode;
  if (introspectionMode) {
    camera.position.z = 1;
    d3.select("#mindscape").style("opacity", 0.3);
    d3.select("#anus-portal").style("transform", "translate(-50%, -50%) scale(1.5)");
    d3.select("#anal-vortex").style("opacity", "1");
  } else {
    camera.position.z = 3;
    d3.select("#mindscape").style("opacity", 1);
    d3.select("#anus-portal").style("transform", "translate(-50%, -50%) scale(1)");
    d3.select("#anal-vortex").style("opacity", "0.7");
  }
});

document.getElementById('boost').addEventListener('click', () => {
  consciousnessLevel = Math.min(consciousnessLevel + 0.1, 1);
  d3.select("#consciousness")
    .text(`Expanded Anal Consciousness Level: ${Math.floor(consciousnessLevel * 100)}%`)
    .style("color", "var(--accent-color)")
    .transition()
    .duration(1000)
    .style("color", "var(--text-color)");
});

let sphincterControlled = false;
document.getElementById('sphincter-control').addEventListener('click', () => {
  sphincterControlled = !sphincterControlled;
  if (sphincterControlled) {
    document.getElementById('anus-portal').style.animation = 'none';
    document.getElementById('sphincter-control').textContent = 'Release Sphincter';
  } else {
    document.getElementById('anus-portal').style.animation = 'pulse 2s infinite alternate';
    document.getElementById('sphincter-control').textContent = 'Control Sphincter';
  }
});

document.addEventListener('keydown', (event) => {
  const speed = 0.1;
  switch(event.key) {
    case 'ArrowUp':
      camera.position.y += speed;
      break;
    case 'ArrowDown':
      camera.position.y -= speed;
      break;
    case 'ArrowLeft':
      camera.position.x -= speed;
      break;
    case 'ArrowRight':
      camera.position.x += speed;
      break;
  }
});

// Responsive design
window.addEventListener('resize', () => {
  const width = window.innerWidth;
  const height = window.innerHeight;
  
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
  
  svg.attr("width", width).attr("height", height);
  updateNeuralNet();
});

// Add visual feedback for user interactions
function addRippleEffect(event) {
  const ripple = document.createElement('div');
  ripple.className = 'ripple';
  ripple.style.left = `${event.clientX}px`;
  ripple.style.top = `${event.clientY}px`;
  document.body.appendChild(ripple);
  setTimeout(() => ripple.remove(), 1000);
}

document.body.addEventListener('click', addRippleEffect);

// Modern loading indicator
const loadingIndicator = document.createElement('div');
loadingIndicator.id = 'loading-indicator';
loadingIndicator.innerHTML = 'Initializing Expanded Quantum Anus Mindscape...';
document.body.appendChild(loadingIndicator);

window.addEventListener('load', () => {
  loadingIndicator.style.opacity = '0';
  setTimeout(() => loadingIndicator.remove(), 1000);
});

// Anus portal pulsation
function pulsateAnusPortal() {
  const portal = document.getElementById('anus-portal');
  if (!sphincterControlled) {
    portal.style.transform = `translate(-50%, -50%) scale(${1 + Math.sin(Date.now() / 1000) * 0.1})`;
  }
  requestAnimationFrame(pulsateAnusPortal);
}
pulsateAnusPortal();

// Thought vector emergence from anus
function emergeThoughtVector() {
  const portal = document.getElementById('anus-portal');
  const rect = portal.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  
  const event = new MouseEvent('click', {
    clientX: centerX + (Math.random() - 0.5) * rect.width,
    clientY: centerY + (Math.random() - 0.5) * rect.height
  });
  
  createThoughtVector(event);
  
  setTimeout(emergeThoughtVector, Math.random() * 5000 + 2000);
}
emergeThoughtVector();

// Create sphincter muscles
function createSphincters() {
  const anusPortal = document.getElementById('anus-portal');
  const sphincterCount = 3;
  
  for (let i = 0; i < sphincterCount; i++) {
    const sphincter = document.createElement('div');
    sphincter.className = 'sphincter';
    sphincter.style.width = `${150 - i * 30}px`;
    sphincter.style.height = `${150 - i * 30}px`;
    sphincter.style.top = `${25 + i * 15}px`;
    sphincter.style.left = `${25 + i * 15}px`;
    anusPortal.appendChild(sphincter);
  }
}
createSphincters();

// Anal vortex rotation
function rotateAnalVortex() {
  const vortex = document.getElementById('anal-vortex');
  vortex.style.transform = `translate(-50%, -50%) rotate(${Date.now() / 50}deg)`;
  requestAnimationFrame(rotateAnalVortex);
}
rotateAnalVortex();

// Rectal passage peristalsis
function animatePeristalsis() {
  const rectalFolds = document.querySelectorAll('.rectal-fold');
  rectalFolds.forEach((fold, index) => {
    fold.style.animation = `peristalsis 5s infinite linear ${index * 0.5}s`;
  });
}
animatePeristalsis();

// Enhanced thought vector creation
function createEnhancedThoughtVector(event) {
  const thoughtVector = document.createElement("div");
  thoughtVector.className = "thought-vector";
  thoughtVector.style.left = event.clientX + "px";
  thoughtVector.style.top = event.clientY + "px";
  thoughtVector.style.width = Math.random() * 100 + 50 + "px";
  thoughtVector.style.height = thoughtVector.style.width;
  thoughtVector.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
  thoughtVector.style.borderRadius = "50%";
  thoughtVector.style.filter = "blur(5px)";
  document.body.appendChild(thoughtVector);
  
  svg.append("path")
     .attr("d", `M${width/2},${height/2} Q${event.clientX},${event.clientY} ${event.clientX+50},${event.clientY+50}`)
     .attr("stroke", thoughtVector.style.backgroundColor)
     .attr("fill", "none")
     .attr("stroke-width", 2)
     .transition()
     .duration(2000)
     .attrTween("stroke-dasharray", function() {
       const len = this.getTotalLength();
       return function(t) { return `${t * len},${len}`; };
     })
     .remove();
  
  setTimeout(() => {
    thoughtVector.style.transform = "scale(0)";
    thoughtVector.style.opacity = "0";
    setTimeout(() => thoughtVector.remove(), 1000);
  }, 7000);
}

document.body.removeEventListener("click", createThoughtVector);
document.body.addEventListener("click", createEnhancedThoughtVector);

// Consciousness expansion effect
function expandConsciousness() {
  const expansion = document.createElement('div');
  expansion.style.position = 'absolute';
  expansion.style.top = '50%';
  expansion.style.left = '50%';
  expansion.style.width = '10px';
  expansion.style.height = '10px';
  expansion.style.borderRadius = '50%';
  expansion.style.backgroundColor = 'rgba(255, 105, 180, 0.5)';
  expansion.style.transform = 'translate(-50%, -50%)';
  expansion.style.transition = 'all 2s ease-out';
  document.body.appendChild(expansion);

  setTimeout(() => {
    expansion.style.width = '100vw';
    expansion.style.height = '100vw';
    expansion.style.opacity = '0';
  }, 100);

  setTimeout(() => {
    expansion.remove();
  }, 2000);
}

document.getElementById('boost').addEventListener('click', expandConsciousness);

// Add some quantum fluctuations
function quantumFluctuations() {
  const fluctuation = document.createElement('div');
  fluctuation.style.position = 'absolute';
  fluctuation.style.width = '2px';
  fluctuation.style.height = '2px';
  fluctuation.style.backgroundColor = 'white';
  fluctuation.style.borderRadius = '50%';
  fluctuation.style.opacity = '0.7';
  fluctuation.style.left = `${Math.random() * 100}%`;
  fluctuation.style.top = `${Math.random() * 100}%`;
  fluctuation.style.animation = 'pulsate 0.5s ease-out';
  document.body.appendChild(fluctuation);

  setTimeout(() => fluctuation.remove(), 500);
}

setInterval(quantumFluctuations, 100);
</script>
</body></html>